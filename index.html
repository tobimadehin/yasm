<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YASM Demo - Yet Another State Manager</title>

    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React and ReactDOM from CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel Standalone for JSX transpilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* Custom styles for the demo */
        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: .5;
            }
        }

        /* Ensure debug monitor is properly positioned */
        .fixed {
            position: fixed;
        }

        .z-50 {
            z-index: 50;
        }

        .z-60 {
            z-index: 60;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        const { useState, useEffect, useCallback, useRef, useMemo } = React;

        // YASM Implementation - Simplified for demo

        // Time parser
        const parseTime = (time) => {
            if (typeof time === 'number') return Math.max(0, time);

            const timeStr = time.toString().trim().toLowerCase();

            if (/^\d+$/.test(timeStr)) {
                return Math.max(0, parseInt(timeStr, 10));
            }

            const match = timeStr.match(/^(\d+(?:\.\d+)?)\s*([a-z]+)$/);
            if (!match) {
                throw new Error(`Invalid time format: "${time}"`);
            }

            const [, valueStr, unit] = match;
            const value = parseFloat(valueStr);

            const units = {
                s: 1000, sec: 1000, second: 1000, seconds: 1000,
                m: 60 * 1000, min: 60 * 1000, minute: 60 * 1000, minutes: 60 * 1000,
                h: 60 * 60 * 1000, hr: 60 * 60 * 1000, hour: 60 * 60 * 1000, hours: 60 * 60 * 1000
            };

            const multiplier = units[unit];
            if (!multiplier) {
                throw new Error(`Invalid time unit: "${unit}"`);
            }

            return Math.round(value * multiplier);
        };

        const formatTime = (ms) => {
            if (ms < 0) return '0s';

            const units = [
                { name: 'h', value: 60 * 60 * 1000 },
                { name: 'm', value: 60 * 1000 },
                { name: 's', value: 1000 }
            ];

            for (const unit of units) {
                const count = Math.floor(ms / unit.value);
                if (count > 0) {
                    return `${count}${unit.name}`;
                }
            }

            return '0s';
        };

        // Simple storage manager for demo
        class SimpleStorage {
            constructor() {
                this.prefix = 'yasm_';
                this.isSupported = typeof localStorage !== 'undefined';
            }

            buildKey(key) {
                return `${this.prefix}${key}`;
            }

            set(key, data, ttl) {
                if (!this.isSupported || !key) return false;

                try {
                    const now = Date.now();
                    const item = {
                        data,
                        timestamp: now,
                        ttl,
                        expiresAt: now + ttl,
                        hits: 0,
                        lastAccess: now,
                        size: JSON.stringify(data).length * 2
                    };

                    localStorage.setItem(this.buildKey(key), JSON.stringify(item));
                    return true;
                } catch {
                    return false;
                }
            }

            get(key) {
                if (!this.isSupported || !key) return null;

                try {
                    const stored = localStorage.getItem(this.buildKey(key));
                    if (!stored) return null;

                    const item = JSON.parse(stored);
                    const now = Date.now();

                    if (now >= item.expiresAt) {
                        this.remove(key);
                        return null;
                    }

                    // Update stats
                    if (now - item.lastAccess > 5000) {
                        item.hits++;
                        item.lastAccess = now;
                        localStorage.setItem(this.buildKey(key), JSON.stringify(item));
                    }

                    return item.data;
                } catch {
                    return null;
                }
            }

            remove(key) {
                if (!this.isSupported || !key) return false;
                try {
                    localStorage.removeItem(this.buildKey(key));
                    return true;
                } catch {
                    return false;
                }
            }

            getCacheKeys() {
                if (!this.isSupported) return [];

                const keys = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(this.prefix)) {
                        keys.push(key.replace(this.prefix, ''));
                    }
                }
                return keys;
            }

            getItemInfo(key) {
                if (!this.isSupported || !key) return null;

                try {
                    const stored = localStorage.getItem(this.buildKey(key));
                    return stored ? JSON.parse(stored) : null;
                } catch {
                    return null;
                }
            }

            clear() {
                if (!this.isSupported) return false;

                try {
                    const keys = this.getCacheKeys();
                    keys.forEach(key => {
                        localStorage.removeItem(this.buildKey(key));
                    });
                    return true;
                } catch {
                    return false;
                }
            }
        }

        const storage = new SimpleStorage();
        const activeRequests = new Map();
        const refreshIntervals = new Map();

        // Main useData hook
        const useData = (key, fetcher, refreshInterval = false) => {
            const [data, setData] = useState(undefined);
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState(null);
            const [isFromCache, setIsFromCache] = useState(false);

            const mountedRef = useRef(true);

            const refreshMs = useMemo(() => {
                if (refreshInterval === false) return null;
                try {
                    return parseTime(refreshInterval);
                } catch {
                    return null;
                }
            }, [refreshInterval]);

            const enhancedFetcher = useCallback(async (isBackgroundRefresh = false) => {
                if (!key || !fetcher) return undefined;

                const existingRequest = activeRequests.get(key);
                if (existingRequest) {
                    try {
                        return await existingRequest;
                    } catch (error) {
                        const cached = storage.get(key);
                        if (cached) return cached;
                        throw error;
                    }
                }

                const requestPromise = (async () => {
                    try {
                        const result = await fetcher();

                        if (result !== undefined && refreshMs) {
                            storage.set(key, result, refreshMs);
                        }

                        return result;
                    } finally {
                        activeRequests.delete(key);
                    }
                })();

                activeRequests.set(key, requestPromise);
                return requestPromise;
            }, [key, fetcher, refreshMs]);

            // Load initial data
            useEffect(() => {
                if (!key || !fetcher) {
                    setData(undefined);
                    setIsFromCache(false);
                    setLoading(false);
                    setError(null);
                    return;
                }

                let isMounted = true;

                const loadData = async () => {
                    const cached = storage.get(key);
                    if (cached && isMounted) {
                        setData(cached);
                        setIsFromCache(true);
                        setLoading(false);
                        setError(null);
                    } else {
                        setLoading(true);
                        setIsFromCache(false);
                    }

                    try {
                        const freshData = await enhancedFetcher(!!cached);

                        if (isMounted && freshData !== undefined) {
                            setData(freshData);
                            setIsFromCache(false);
                            setError(null);
                        }
                    } catch (err) {
                        if (!isMounted) return;

                        const error = err instanceof Error ? err : new Error(String(err));

                        if (cached) {
                            setData(cached);
                            setIsFromCache(true);
                            setError(error);
                        } else {
                            setData(undefined);
                            setIsFromCache(false);
                            setError(error);
                        }
                    } finally {
                        if (isMounted) {
                            setLoading(false);
                        }
                    }
                };

                loadData();

                return () => {
                    isMounted = false;
                };
            }, [key, fetcher, enhancedFetcher]);

            // Auto-refresh
            useEffect(() => {
                if (!key || !refreshMs || refreshMs <= 0) {
                    return;
                }

                const existingInterval = refreshIntervals.get(key);
                if (existingInterval) {
                    clearInterval(existingInterval);
                }

                const interval = setInterval(async () => {
                    if (!mountedRef.current) return;

                    try {
                        const freshData = await enhancedFetcher(true);
                        if (mountedRef.current && freshData !== undefined) {
                            setData(freshData);
                            setIsFromCache(false);
                            setError(null);
                        }
                    } catch (err) {
                        if (mountedRef.current) {
                            setError(err instanceof Error ? err : new Error(String(err)));
                        }
                    }
                }, refreshMs);

                refreshIntervals.set(key, interval);

                return () => {
                    clearInterval(interval);
                    refreshIntervals.delete(key);
                };
            }, [key, refreshMs, enhancedFetcher]);

            const refresh = useCallback(async () => {
                if (!key || !fetcher) return;

                setLoading(true);
                setError(null);

                try {
                    const freshData = await enhancedFetcher(false);
                    if (mountedRef.current && freshData !== undefined) {
                        setData(freshData);
                        setIsFromCache(false);
                    }
                } catch (err) {
                    if (!mountedRef.current) return;

                    const error = err instanceof Error ? err : new Error(String(err));
                    const cached = storage.get(key);
                    if (cached) {
                        setData(cached);
                        setIsFromCache(true);
                    }
                    setError(error);
                } finally {
                    if (mountedRef.current) {
                        setLoading(false);
                    }
                }
            }, [key, fetcher, enhancedFetcher]);

            const clear = useCallback(() => {
                if (!key) return;
                storage.remove(key);
                setData(undefined);
                setIsFromCache(false);
                setError(null);
            }, [key]);

            useEffect(() => {
                mountedRef.current = true;
                return () => {
                    mountedRef.current = false;
                };
            }, []);

            return { data, loading, error, isFromCache, refresh, clear };
        };

        // Mock APIs
        const api = {
            fetchDashboard: async () => {
                await new Promise(resolve => setTimeout(resolve, 800));
                return {
                    revenue: Math.floor(Math.random() * 100000),
                    users: Math.floor(Math.random() * 1000),
                    timestamp: new Date().toISOString()
                };
            },

            fetchUser: async (userId) => {
                await new Promise(resolve => setTimeout(resolve, 600));
                return {
                    id: userId,
                    name: 'John Doe',
                    email: 'john@example.com',
                    avatar: 'ðŸ‘¤'
                };
            },

            fetchNotifications: async () => {
                await new Promise(resolve => setTimeout(resolve, 400));
                return [
                    { id: 1, message: 'New user registered', time: new Date().toISOString() },
                    { id: 2, message: 'Payment received', time: new Date().toISOString() },
                    { id: 3, message: 'Server health check passed', time: new Date().toISOString() }
                ];
            }
        };

        // Components
        function Dashboard() {
            const { data, loading, isFromCache, refresh } = useData(
                'dashboard',
                api.fetchDashboard,
                '30s'
            );

            return (
                <div className="bg-white p-6 rounded-lg shadow-lg">
                    <div className="flex items-center justify-between mb-4">
                        <h2 className="text-xl font-bold">Dashboard</h2>
                        <div className="flex items-center gap-2">
                            {isFromCache && (
                                <span className="px-2 py-1 bg-blue-100 text-blue-800 text-xs rounded">
                                    ðŸ“¦ Instant Load
                                </span>
                            )}
                            {loading && (
                                <span className="px-2 py-1 bg-yellow-100 text-yellow-800 text-xs rounded">
                                    ðŸ”„ Refreshing...
                                </span>
                            )}
                            <button
                                onClick={refresh}
                                className="px-3 py-1 bg-blue-500 text-white text-xs rounded hover:bg-blue-600"
                            >
                                Refresh
                            </button>
                        </div>
                    </div>

                    {data ? (
                        <div className="grid grid-cols-2 gap-4">
                            <div className="text-center p-4 bg-green-50 rounded">
                                <div className="text-2xl font-bold text-green-600">
                                    ${data.revenue.toLocaleString()}
                                </div>
                                <div className="text-sm text-gray-600">Revenue</div>
                            </div>
                            <div className="text-center p-4 bg-blue-50 rounded">
                                <div className="text-2xl font-bold text-blue-600">
                                    {data.users.toLocaleString()}
                                </div>
                                <div className="text-sm text-gray-600">Users</div>
                            </div>
                        </div>
                    ) : (
                        <div className="grid grid-cols-2 gap-4">
                            <div className="h-20 bg-gray-200 animate-pulse rounded"></div>
                            <div className="h-20 bg-gray-200 animate-pulse rounded"></div>
                        </div>
                    )}
                </div>
            );
        }

        function UserProfile({ userId }) {
            const { data: user, loading, isFromCache, clear } = useData(
                `user-${userId}`,
                () => api.fetchUser(userId),
                '5m'
            );

            return (
                <div className="bg-white p-6 rounded-lg shadow-lg">
                    <div className="flex items-center justify-between mb-4">
                        <h2 className="text-xl font-bold">User Profile</h2>
                        <div className="flex items-center gap-2">
                            {isFromCache && (
                                <span className="px-2 py-1 bg-green-100 text-green-800 text-xs rounded">
                                    ðŸ“¦ Cached
                                </span>
                            )}
                            <button
                                onClick={clear}
                                className="px-3 py-1 bg-red-500 text-white text-xs rounded hover:bg-red-600"
                            >
                                Clear
                            </button>
                        </div>
                    </div>

                    {loading && !user ? (
                        <div className="animate-pulse">
                            <div className="h-4 bg-gray-200 rounded w-1/2 mb-2"></div>
                            <div className="h-4 bg-gray-200 rounded w-1/3"></div>
                        </div>
                    ) : user ? (
                        <div className="flex items-center gap-3">
                            <div className="text-3xl">{user.avatar}</div>
                            <div>
                                <div className="font-semibold">{user.name}</div>
                                <div className="text-gray-600">{user.email}</div>
                                <div className="text-xs text-gray-500">ID: {user.id}</div>
                            </div>
                        </div>
                    ) : (
                        <div className="text-gray-500">Failed to load user</div>
                    )}
                </div>
            );
        }

        function Notifications() {
            const { data: notifications, loading, isFromCache } = useData(
                'notifications',
                api.fetchNotifications,
                '10s'
            );

            return (
                <div className="bg-white p-6 rounded-lg shadow-lg">
                    <div className="flex items-center justify-between mb-4">
                        <h2 className="text-xl font-bold">Notifications</h2>
                        {isFromCache && (
                            <span className="px-2 py-1 bg-orange-100 text-orange-800 text-xs rounded">
                                ðŸ“¦ From Cache
                            </span>
                        )}
                    </div>

                    {loading && !notifications ? (
                        <div className="space-y-2">
                            {[1, 2, 3].map(i => (
                                <div key={i} className="h-12 bg-gray-200 animate-pulse rounded"></div>
                            ))}
                        </div>
                    ) : (
                        <div className="space-y-2">
                            {notifications?.map(notification => (
                                <div key={notification.id} className="p-3 bg-gray-50 rounded border-l-4 border-blue-500">
                                    <div className="font-medium">{notification.message}</div>
                                    <div className="text-sm text-gray-600">
                                        {new Date(notification.time).toLocaleTimeString()}
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        }

        function App() {
            const userId = 'user-123';

            return (
                <div className="min-h-screen bg-gray-100 p-8">
                    <div className="max-w-4xl mx-auto">
                        <div className="flex items-center justify-between mb-8">
                            <h1 className="text-3xl font-bold">YASM Demo - Yet Another State Manager ðŸš€</h1>
                        </div>

                        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                            <Dashboard />
                            <UserProfile userId={userId} />
                        </div>

                        <div className="mb-6">
                            <Notifications />
                        </div>

                        <div className="bg-white p-6 rounded-lg shadow-lg">
                            <h2 className="text-xl font-bold mb-4">YASM Usage Patterns</h2>

                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
                                <div className="p-4 bg-blue-50 rounded">
                                    <h3 className="font-semibold mb-2">ðŸš€ Real-time Data</h3>
                                    <code className="text-xs">useData('live', fetch, '10s')</code>
                                    <p className="mt-2 text-gray-600">Perfect for live feeds, notifications</p>
                                </div>

                                <div className="p-4 bg-green-50 rounded">
                                    <h3 className="font-semibold mb-2">ðŸ“Š Dashboard Data</h3>
                                    <code className="text-xs">useData('stats', fetch, '30s')</code>
                                    <p className="mt-2 text-gray-600">Standard for analytics dashboards</p>
                                </div>

                                <div className="p-4 bg-purple-50 rounded">
                                    <h3 className="font-semibold mb-2">ðŸ‘¤ User Data</h3>
                                    <code className="text-xs">useData('user', fetch, '5m')</code>
                                    <p className="mt-2 text-gray-600">Longer cache for stable data</p>
                                </div>
                            </div>

                            <div className="mt-4 p-4 bg-gray-50 rounded">
                                <h3 className="font-semibold mb-2">Key Benefits</h3>
                                <ul className="text-sm text-gray-600 space-y-1">
                                    <li>âœ… <strong>Instant loading</strong> from cache (0.1ms)</li>
                                    <li>âœ… <strong>Background updates</strong> keep data fresh</li>
                                    <li>âœ… <strong>Request deduplication</strong> prevents duplicate fetches</li>
                                    <li>âœ… <strong>Error recovery</strong> with cache fallback</li>
                                    <li>âœ… <strong>Human-friendly time formats</strong> ('30s', '5m', '2h')</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>